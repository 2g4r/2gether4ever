###Welcome to use object

### *this*的对象取决于它的调用方式  
+ 全局环境中的`this`指向**全局变量**。因此this的对象是window（全局变量其实是window对象的一个属性）  
+ 作为对象的方法调用（**打点调用**）的时候，this指向该对象  
+ 作为构造函数使用，使用**new**关键字，通过构造函数生成一个实例对象。此时，this指向这个新对象。<br>如果构造函数返回了一个对象，this指向返回的对象。如果构造函数返回非引用类型（string，number，boolean，null，undefined），this仍然指向实例化的新对象  
+ 改变this的指向，可以使用**call**或**apply**方法。（只有函数能够打点调用call（）和apply（），表示用指定的上下文执行这个函数）<br>call和apply的区别在于，call的第二个及后续参数是一个参数列表，apply的第二个参数是数组，参数列表和参数数组都将作为函数的参数进行执行  
+ **bind**方法会创建一个新还书，新函数的this会永久的指向bind传入的第一个参数  
+ **箭头函数** ES6新增。箭头函数不仅更加整洁，还对this的指向进行了改进。箭头函数会从**作用域的上一层**继承this。<br>无法通过call和apply改变其this指向  

###函数的上下文  
+ 函数用圆括号调用，函数的上下文是**window对象**<br>*注：<br>所有的全局变量都是widow属性 <br>函数内部的局部变量不是window属性，不是任何东西的属性，它就是一个变量*  
+ 函数作用一个对象的方法，对象打点调用，函数的上下文就是**这个对象**  
+ 函数是事件处理函数，函数的上下文是**事件触发对象**。把听一个函数绑定给了不同的对象，点击谁，this就是谁  
+ 定时器调用函数，this的对象是**window**  
+ 数组中存放的函数，被数组索引调用，上下文就是**这个函数**  

###构造函数  
**定义**：当一个函数被new调用时，这个函数叫_构造函数_  

用new运算符调用，函数上下文是一个全新的对象      

**四步走**：  
1. 函数内部悄悄创建一个局部变量，是一个空对象{}  
2. 函数将自己的上下文设置为这个{}，即所有语句中的this表示这个空对象{}  
3. 函数将执行所有语句  
4. 所有语句执行后，函数将return这个对象，函数将自己的上下文返回  

用new操作符可以返回具有相同属性群的对象  

###原型链  
每一个构造函数都有一个prototype，指向一个对象  
当这个函数被new调用，它的每一个示例的_proto_属性，也指向这个对象  
*注：构造函数的prototype天生存在，不需要定义，这个属性对它自己而言 没有任何意义*  
构造函数的prototype指向谁，它new出来的儿子的_proto_就指向谁   
我们称people.prototype是people构造函数的“原型”，people.prototype是xiaoming的“原型对象”  

**_prototype_**是神器，有原型链查找功能，当xiaoming身上没有某个属性的时候，系统会沿着_proto_去查找它的原型对象身上有没有这个属性  

  
